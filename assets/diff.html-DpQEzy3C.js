import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,d as n,o as i}from"./app-C9qP9JtV.js";const r="/blog/assets/image-36-BaQE1sdr.png",l="/blog/assets/image-37-BnofX65W.png",o="/blog/assets/image-38-C9iBA-wR.png",d="/blog/assets/image-39-CMzVpaYg.png",s="/blog/assets/image-40-Mv2AMXPX.png",p="/blog/assets/image-41-SU12QTB2.png",c="/blog/assets/image-42-Bdzt8lut.png",m="/blog/assets/image-43-BPqCa32z.png",g="/blog/assets/image-44-D1t1wDFM.png",b="/blog/assets/image-45-BrBJGXLT.png",f="/blog/assets/image-46-CzwA97IP.png",x="/blog/assets/image-47-DMiwbzqI.png",h="/blog/assets/image-48-oUbi8HrQ.png",_="/blog/assets/image-49-C_Yq3af8.png",y="/blog/assets/image-50-D6jC4kne.png",u={};function V(z,t){return i(),a("div",null,t[0]||(t[0]=[n('<h1 id="diff算法" tabindex="-1"><a class="header-anchor" href="#diff算法"><span>diff算法</span></a></h1><p>一种通过同层的树节点进行比较的高效算法</p><ol><li>比较只会再同层级进行,不会跨层级比较<br><img src="'+r+'" alt="alt text" loading="lazy"></li><li>在diff比较的过程中,循环从两边向中间收拢<br><img src="'+l+'" alt="alt text" loading="lazy"><br> 例子<br><img src="'+o+'" alt="alt text" loading="lazy"><br> 第一次循环结束后,发现新旧节点D相同,diff后将他作为第一个真实节点,同时endindex移动到c.<br><img src="'+d+'" alt="alt text" loading="lazy"><br> 第二次循环后,新旧节点c相同,diff后建立c的真实节点,startindex移动到e,endindex移动到b<br><img src="'+s+'" alt="alt text" loading="lazy"><br> 第三次循环,没有发现e,直接创建新的真实节点E,startindex移动到a<br><img src="'+p+'" alt="alt text" loading="lazy"><br> 第四次循环,diff创建了a的真实节点,startindex移动到b<br><img src="'+c+'" alt="alt text" loading="lazy"><br> 第五次循环,创建b的真实节点,startindex已经大于endindex,需要创建newStrtIdx和newEndIdx之间的所有节点,即F<br><img src="'+m+'" alt="alt text" loading="lazy"><br> startindex已经大于endindex,退出循环,创建newStrtIdx和newEndIdx之间的所有节点,即F<br><img src="'+g+'" alt="alt text" loading="lazy"></li></ol><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><p>当数据发生改变时,set方法会调用Dep.notify通知所有的订阅者Watcher,订阅者就会调用pacth给真实DOM打补丁,更新相应的视图</p><ol><li>patch方法接受参数,oldVnode和Vnode<br><img src="'+b+'" alt="alt text" loading="lazy"><br> 主要做了如下判断:<br> 没有新节点,直接触发旧节点的destory钩子<br> 没有旧节点,直接createElm新建节点<br> 新旧节点自身一样,通过sameVnode判断节点是否一样,一样时,直接调用patchVnode去处理这两个节点<br> 新旧节点自身不一样,直接创建新节点,删除旧的节点</li><li>patchVnode<br><img src="'+f+'" alt="alt text" loading="lazy"><br><img src="'+x+'" alt="alt text" loading="lazy"><br> 主要做了如下判断:<br> 是否是文本节点,如果是,直接更新文本内容<br> 如果存在子节点,则处理比较更新子节点<br> 只有新节点有子节点,旧节点没有,所有的节点都是全新的,直接新建所有的新DOM,并且加入父节点<br> 只有旧节点有子节点,把所有的旧节点删除,直接删除DOM</li><li>子节点不完全一致,调用updateChildren<br><img src="'+h+'" alt="alt text" loading="lazy"><br><img src="'+_+'" alt="alt text" loading="lazy"><br><img src="'+y+'" alt="alt text" loading="lazy"><br> 处理了五种情景:<br> 新老节点的start相同,直接patchVnode,新老节点的start索引+1<br> 新老节点的end相同,直接patchVnode,新老节点的end索引-1<br> 老节点的start和新节点的end相同时,patchVnode后,将当前真实DOM移动到oldEndVnode后面,老节点的start索引+1,新节点的end索引-1<br> 老节点的start和新节点的end相同时,patchVnode后,将当前真实DOM移动到oldEndVnode前面,老节点的end索引-1,新节点的start索引+1<br> 如果不满足以上四种情况,则没有节点可以复用，分为以下两种情况<br> 从旧的vnode为key值，对应的index序列为value值的哈希表中寻找到与newStartVnode一致key的旧的vnode节点，在进行patchVnode，同时将这个真实dom移动到oldstartVnode对应的真实dom的前面<br> 调用createElm创建一个新的dom节点放到newStartIdx的位置</li></ol><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>数据发生改变时，订阅者watcher就会调用patch给真实dom打补丁<br> 通过isSameVnode进行判断，相同则调用patchVnode方法<br> patchVnode方法做了以下操作：</p><ol><li>找到对应的真实dom，称为el</li><li>如果都有文本节点且不相等，将el文本节点设置为Vnode的文本节点</li><li>如果oldVnode有子节点而Vnode没有，则删除el子节点</li><li>如果oldVnode没有子节点而Vnode有，则将vnode的子节点真实化后添加到el</li><li>如果两者都有子节点，则执行updateChildren函数比较子节点<br> updateChildren主要做了以下操作</li><li>设置新旧Vnode的头尾指针</li><li>新旧头尾指针进行比较，向循环中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找key一致的Vnode节点再分情况操作</li></ol>',9)]))}const E=e(u,[["render",V],["__file","diff.html.vue"]]),C=JSON.parse('{"path":"/posts/Vue/diff.html","title":"diff算法","lang":"zh-CN","frontmatter":{"date":"2025-03-13T00:00:00.000Z","category":["JS框架"],"tag":["Vue"],"description":"diff算法 一种通过同层的树节点进行比较的高效算法 比较只会再同层级进行,不会跨层级比较 alt text 在diff比较的过程中,循环从两边向中间收拢 alt text 例子 alt text 第一次循环结束后,发现新旧节点D相同,diff后将他作为第一个真实节点,同时endindex移动到c. alt text 第二次循环后,新旧节点c相同,di...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/Vue/diff.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"diff算法"}],["meta",{"property":"og:description","content":"diff算法 一种通过同层的树节点进行比较的高效算法 比较只会再同层级进行,不会跨层级比较 alt text 在diff比较的过程中,循环从两边向中间收拢 alt text 例子 alt text 第一次循环结束后,发现新旧节点D相同,diff后将他作为第一个真实节点,同时endindex移动到c. alt text 第二次循环后,新旧节点c相同,di..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T06:14:43.000Z"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2025-03-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-14T06:14:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"diff算法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-13T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-14T06:14:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xzq\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1752055862000,"updatedTime":1752473683000,"contributors":[{"name":"Gunxzq","username":"Gunxzq","email":"3219988985@qq.com","commits":2,"url":"https://github.com/Gunxzq"}]},"readingTime":{"minutes":3.52,"words":1056},"filePathRelative":"posts/Vue/diff.md","localizedDate":"2025年3月13日","excerpt":"\\n<p>一种通过同层的树节点进行比较的高效算法</p>\\n<ol>\\n<li>比较只会再同层级进行,不会跨层级比较<br>\\n</li>\\n<li>在diff比较的过程中,循环从两边向中间收拢<br>\\n<br>\\n例子<br>\\n<br>\\n第一次循环结束后,发现新旧节点D相同,diff后将他作为第一个真实节点,同时endindex移动到c.<br>\\n<br>\\n第二次循环后,新旧节点c相同,diff后建立c的真实节点,startindex移动到e,endindex移动到b<br>\\n<br>\\n第三次循环,没有发现e,直接创建新的真实节点E,startindex移动到a<br>\\n<br>\\n第四次循环,diff创建了a的真实节点,startindex移动到b<br>\\n<br>\\n第五次循环,创建b的真实节点,startindex已经大于endindex,需要创建newStrtIdx和newEndIdx之间的所有节点,即F<br>\\n<br>\\nstartindex已经大于endindex,退出循环,创建newStrtIdx和newEndIdx之间的所有节点,即F<br>\\n</li>\\n</ol>","autoDesc":true}');export{E as comp,C as data};
