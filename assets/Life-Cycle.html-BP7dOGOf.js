import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,d as t,o as a}from"./app-Bqkh5_iM.js";const n="/blog/assets/image-BRgfzmK5.png",p="/blog/assets/image-2-DsGbbpgS.png",l={};function r(o,e){return a(),i("div",null,e[0]||(e[0]=[t(`<h1 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h1><p>React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。</p><h2 id="流程" tabindex="-1"><a class="header-anchor" href="#流程"><span>流程</span></a></h2><p>react16.4之后的生命周期，可以分成三个阶段：</p><ul><li>创建阶段</li><li>更新阶段</li><li>卸载阶段</li></ul><h3 id="创建阶段" tabindex="-1"><a class="header-anchor" href="#创建阶段"><span>创建阶段</span></a></h3><p>创建阶段主要分成了以下几个生命周期方法：</p><ul><li>constructor</li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount</li></ul><h4 id="constructor" tabindex="-1"><a class="header-anchor" href="#constructor"><span>constructor</span></a></h4><p>实例过程中自动调用的方法，在方法内部通过super关键字获取来自父组件的props<br> 在该方法中，通常的操作为初始化state状态或者在this上挂载方法</p><h4 id="getderivedstatefromprops" tabindex="-1"><a class="header-anchor" href="#getderivedstatefromprops"><span>getDerivedStateFromProps</span></a></h4><p>该方法是新增的生命周期方法，是一个静态的方法，因此不能访问到组件的实例<br> 执行时机：组件创建和更新阶段，不论是props变化还是state变化，也会调用<br> 在每次render方法前调用，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和 state来加一些限制条件，防止无用的state更新<br> 该方法需要返回一个新的对象作为新的state或者返回null表示state状态不需要更新</p><h4 id="render" tabindex="-1"><a class="header-anchor" href="#render"><span>render</span></a></h4><p>类组件必须实现的方法，用于渲染DOM结构，可以访问组件state与prop属性</p><div class="hint-container important"><p class="hint-container-title">重要</p><p>不要在 render 里面 setState, 否则会触发死循环导致内存崩溃</p></div><h4 id="componentdidmount" tabindex="-1"><a class="header-anchor" href="#componentdidmount"><span>componentDidMount</span></a></h4><p>组件挂载到真实DOM节点后执行，其在render方法之后执行<br> 此方法多用于执行一些数据获取，事件监听等操作</p><h3 id="更新阶段" tabindex="-1"><a class="header-anchor" href="#更新阶段"><span>更新阶段</span></a></h3><p>该阶段的函数主要为如下方法：</p><ul><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>render</li><li>getSnapshotBeforeUpdate</li><li>componentDidUpdate</li></ul><h4 id="shouldcomponentupdate" tabindex="-1"><a class="header-anchor" href="#shouldcomponentupdate"><span>shouldComponentUpdate</span></a></h4><p>用于告知组件本身基于当前的props和state是否需要重新渲染组件，默认情况返回true<br> 执行时机：到新的props或者state时都会调用，通过返回true或者false告知组件更新与否<br> 一般情况，不建议在该周期方法中进行深层比较，会影响效率<br> 同时也不能调用setState，否则会导致无限循环调用更新</p><h4 id="getsnapshotbeforeupdate" tabindex="-1"><a class="header-anchor" href="#getsnapshotbeforeupdate"><span>getSnapshotBeforeUpdate</span></a></h4><p>该周期函数在render后执行，执行之时DOM元素还没有被更新<br> 该方法返回的一个Snapshot值，作为componentDidUpdate第三个参数传入</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getSnapshotBeforeUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">prevProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">prevState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;#enter getSnapshotBeforeUpdate&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;foo&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">componentDidUpdate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">prevProps</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">prevState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">snapshot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;#enter componentDidUpdate snapshot = &#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">snapshot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态</p><h4 id="componentdidupdate" tabindex="-1"><a class="header-anchor" href="#componentdidupdate"><span>componentDidUpdate</span></a></h4><p>执行时机：组件更新结束后触发<br> 在该方法中，可以根据前后的props和state的变化做相应的操作，如获取数据，修改DOM样式等</p><h3 id="卸载阶段" tabindex="-1"><a class="header-anchor" href="#卸载阶段"><span>卸载阶段</span></a></h3><h4 id="componentwillunmount" tabindex="-1"><a class="header-anchor" href="#componentwillunmount"><span>componentWillUnmount</span></a></h4><p>此方法用于组件卸载前，清理一些注册是监听事件，或者取消订阅的网络请求等<br> 一旦一个组件实例被卸载，其不会被再次挂载，而只可能是被重新创建</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>新版生命周期整体流程如下图所示：<br><img src="`+n+'" alt="alt text" loading="lazy"><br> 旧的生命周期流程图如下：<br><img src="'+p+'" alt="alt text" loading="lazy"><br> 通过两个图的对比，可以发现新版的生命周期减少了以下三种方法：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>componentWillUpdate</li></ul><p>其实这三个方法仍然存在，只是在前者加上了UNSAFE_前缀，如UNSAFE_componentWillMount，并不像字面意思那样表示不安全，而是表示这些生命周期的代码可能在未来的 react 版本可能废除</p><p>同时也新增了两个生命周期函数：</p><ul><li>getDerivedStateFromProps<br> = getSnapshotBeforeUpdate</li></ul>',37)]))}const c=s(l,[["render",r],["__file","Life-Cycle.html.vue"]]),k=JSON.parse('{"path":"/posts/React/Life-Cycle.html","title":"生命周期","lang":"zh-CN","frontmatter":{"date":"2025-06-22T00:00:00.000Z","order":2,"category":["React"],"tag":["React"],"description":"生命周期 React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。 流程 react16.4之后的生命周期，可以分成三个阶段： 创建阶段 更新阶段 卸载阶段 创建阶段 创建阶段主要分成了以下几个生命周期方法： constructor getDerivedStateFromProps render co...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/React/Life-Cycle.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"生命周期"}],["meta",{"property":"og:description","content":"生命周期 React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。 流程 react16.4之后的生命周期，可以分成三个阶段： 创建阶段 更新阶段 卸载阶段 创建阶段 创建阶段主要分成了以下几个生命周期方法： constructor getDerivedStateFromProps render co..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-15T02:34:25.000Z"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:published_time","content":"2025-06-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-15T02:34:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"生命周期\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-22T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-15T02:34:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xzq\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"流程","slug":"流程","link":"#流程","children":[{"level":3,"title":"创建阶段","slug":"创建阶段","link":"#创建阶段","children":[]},{"level":3,"title":"更新阶段","slug":"更新阶段","link":"#更新阶段","children":[]},{"level":3,"title":"卸载阶段","slug":"卸载阶段","link":"#卸载阶段","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1752546865000,"updatedTime":1752546865000,"contributors":[{"name":"Gunxzq","username":"Gunxzq","email":"3219988985@qq.com","commits":1,"url":"https://github.com/Gunxzq"}]},"readingTime":{"minutes":3.11,"words":934},"filePathRelative":"posts/React/Life-Cycle.md","localizedDate":"2025年6月22日","excerpt":"\\n<p>React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。</p>\\n<h2>流程</h2>\\n<p>react16.4之后的生命周期，可以分成三个阶段：</p>\\n<ul>\\n<li>创建阶段</li>\\n<li>更新阶段</li>\\n<li>卸载阶段</li>\\n</ul>\\n<h3>创建阶段</h3>\\n<p>创建阶段主要分成了以下几个生命周期方法：</p>\\n<ul>\\n<li>constructor</li>\\n<li>getDerivedStateFromProps</li>\\n<li>render</li>\\n<li>componentDidMount</li>\\n</ul>","autoDesc":true}');export{c as comp,k as data};
