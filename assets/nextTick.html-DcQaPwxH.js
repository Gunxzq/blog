import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as r}from"./app-Cpaph37u.js";const i="/blog/assets/image-21-kKD1UYMO.png",o="/blog/assets/image-22-PBuHp467.png",c="/blog/assets/image-23-DPzUPfZ4.png",s={};function p(l,e){return r(),a("div",null,e[0]||(e[0]=[n('<h1 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick"><span>nextTick</span></a></h1><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM.<br> 数据变化后,vue将开启一个异步更新队列,视图需要等待队列中所有的数据变化完成后,再统一进行更新.</p><h2 id="场景" tabindex="-1"><a class="header-anchor" href="#场景"><span>场景</span></a></h2><p><em>Vue.nextTick()</em>,第一个参数是回调函数,第二个参数为执行函数上下文.<br> 返回一个promise对象,可以使用async和await完成相同作用的事情.<br><img src="'+i+'" alt="alt text" loading="lazy"><br> callbacks是异步操作队列,将回调函数压入<br> pending用于标识,同一时间只能执行一次<br> timerFunc()异步延迟函数,根据当前环境选择合适的方法<br><img src="'+o+'" alt="alt text" loading="lazy"><br> 无论是宏任务还是微任务,都会放到flushCallbacks<br><img src="'+c+'" alt="alt text" loading="lazy"></p>',4)]))}const u=t(s,[["render",p],["__file","nextTick.html.vue"]]),h=JSON.parse('{"path":"/posts/Vue/nextTick.html","title":"nextTick","lang":"zh-CN","frontmatter":{"date":"2025-03-10T00:00:00.000Z","category":["JS框架"],"tag":["Vue"],"description":"nextTick 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM. 数据变化后,vue将开启一个异步更新队列,视图需要等待队列中所有的数据变化完成后,再统一进行更新. 场景 Vue.nextTick(),第一个参数是回调函数,第二个参数为执行函数上下文. 返回一个promise对象,可以使用async和aw...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/blog/posts/Vue/nextTick.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"nextTick"}],["meta",{"property":"og:description","content":"nextTick 在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM. 数据变化后,vue将开启一个异步更新队列,视图需要等待队列中所有的数据变化完成后,再统一进行更新. 场景 Vue.nextTick(),第一个参数是回调函数,第二个参数为执行函数上下文. 返回一个promise对象,可以使用async和aw..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-14T06:14:43.000Z"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2025-03-10T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-07-14T06:14:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"nextTick\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-03-10T00:00:00.000Z\\",\\"dateModified\\":\\"2025-07-14T06:14:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xzq\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"场景","slug":"场景","link":"#场景","children":[]}],"git":{"createdTime":1752055862000,"updatedTime":1752473683000,"contributors":[{"name":"Gunxzq","username":"Gunxzq","email":"3219988985@qq.com","commits":2,"url":"https://github.com/Gunxzq"}]},"readingTime":{"minutes":0.75,"words":224},"filePathRelative":"posts/Vue/nextTick.md","localizedDate":"2025年3月10日","excerpt":"\\n<p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM.<br>\\n数据变化后,vue将开启一个异步更新队列,视图需要等待队列中所有的数据变化完成后,再统一进行更新.</p>\\n<h2>场景</h2>\\n<p><em>Vue.nextTick()</em>,第一个参数是回调函数,第二个参数为执行函数上下文.<br>\\n返回一个promise对象,可以使用async和await完成相同作用的事情.<br>\\n<br>\\ncallbacks是异步操作队列,将回调函数压入<br>\\npending用于标识,同一时间只能执行一次<br>\\ntimerFunc()异步延迟函数,根据当前环境选择合适的方法<br>\\n<br>\\n无论是宏任务还是微任务,都会放到flushCallbacks<br>\\n</p>","autoDesc":true}');export{u as comp,h as data};
